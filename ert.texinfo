\input texinfo.tex    @c -*-texinfo-*-
@c %**start of header
@setfilename ert.info
@settitle Emacs Lisp Regression Tests Manual
@c %**end of header

@dircategory Emacs
@direntry
* ERT: (ert).        Emacs Lisp Regression Tests.
@end direntry

@copying
Copyright @copyright{} 2008 Phil Hagelberg

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.
@end quotation
@end copying

@node Top
@top ERT Manual

ERT is a tool for automated testing in Emacs Lisp.  Its main
features are facilities for defining and running test cases and
reporting the results as well as for debugging test failures
interactively.

@menu
* Introduction::
* Defining Tests::
* Should Macro::
* Test Selectors::
* Comparison with Other Test Tools::
@end menu

@node Introduction
@chapter Introduction

ERT is designed for automating test for Emacs Lisp code. It may feel
familiar if you have used classic tools like Test::Unit or xUnit, but
it has a few unique features that take advantage of the dynamic and
interactive nature of Emacs.

@c A bit more about TDD, unit testing, why it's important

@node Defining Tests
@chapter Defining Tests

The @code{ert-deftest} function is used to define a new test. It is
passed a name, an argument list (currently ignored), and a body. This
sample from @file{ert-selftests.el} shows its usage:

@c what's the deal with arg lists being ignored?

@lisp
(ert-deftest addition-test ()
  (should (= (+ 2 2) 4)))
@end lisp

This simply tests that the @code{+} operator is working
correctly. Since it really just calls a function and checks its return
value, it is a good example of a @b{unit test}, which is one of two
types of common automated test. The other is a functional test.

@lisp
(ert-deftest print-test ()
  (save-excursion (with-output-to-temp-buffer
    (should (buffer-changes-p (print "hello"))))))
@end lisp

Functional tests ensure that higher-level functionality is
working. Rather than simply checking the return value, it performs a
more complex operation and ensures that the state after the operation
is as expected.

ERT includes support for both unit tests and functional tests.

@node Should Macro
@chapter Should Macro

Test bodies may include any arbitrary code, but to be useful they will
need to have checks to ensure that the code under test is performing
as expected. @code{should} is similar to cl's @code{assert}, but
signals a different error when its condition is violated that is
caught and processed by ERT. In addition, it analyzes its argument
form and records information that helps debugging.

This test definition:

@lisp
(ert-deftest should-fail ()
             (let ((x 2)
                   (y 4))
               (should (= (+ x y (- x y)) 3))))
@end lisp

will produce this when run via @kbd{M-x ert}:

@example
F should-fail
    (ert-test-failed
     ((should
       (=
        (+ x y ...)
        3))
      :form
      (= 4 3)
      :value nil))
@end example

In addition to @code{should}, ERT provides @code{should-not}, which
ensures that the predicate returns nil and @code{should-error}, which
ensures that the body signals an error.

@node Test Selectors
@chapter Test Selectors

Functions like @code{ert-run-tests-interactively} (aliased to
@code{ert}) accept a test selector, which is a Lisp expression
specifying a set of tests.  Each test name is a selector that refers
to that test, the selector @code{t} refers to all tests, and the
selector @code{:failed} refers to all tests that failed; but more
complex selectors are available. Test selector syntax is similar to
cl's type specifier syntax.

@itemize
@item @code{nil} -- Selects the empty set.
@item @code{t} -- Selects UNIVERSE.
@item @code{:new} -- Selects all tests that have not been run yet.
@item @code{:failed}, @code{:passed}, @code{:error} -- Select tests according to their most recent result.
@item @code{:expected}, @code{:unexpected} -- Select tests according to their most recent result.
@item @code{a string} -- Selects all tests that have a name that matches the string, a regexp.
@item @code{a test} -- Selects that test.
@item @code{a symbol} -- Selects the test that the symbol names, errors if none.
@end itemize

In addition, more complex selectors exist:

@itemize
@item @code{(member TESTS...)} -- Selects TESTS, a list of tests or symbols naming tests.
@item @code{(eql TEST)} -- Selects TEST, a test or a symbol naming a test.
@item @code{(and SELECTORS...)} -- Selects the tests that match all SELECTORS.
@item @code{(or SELECTORS...)} -- Selects the tests that match any SELECTOR.
@item @code{(not SELECTOR)} -- Selects all tests that do not match SELECTOR.
@item @code{(satisfies PREDICATE)} -- Selects all tests that satisfy PREDICATE.
@end itemize

@node Comparison with Other Test Tools
@chapter Comparison with Other Test Tools

ERT allows test-driven development similar to *Unit frameworks for
other languages.  However, two common *Unit features are notably
absent from ERT: fixtures and test suites.

Fixtures, as used e.g. in SUnit or JUnit, have two main purposes:
Setting up (and tearing down) an environment for a set of test
cases, and making that environment accessible through object
attributes that can be used like local variables.

While fixtures are a great syntactic simplification in other
languages, they are not very useful in Lisp, where higher-order
functions and `unwind-protect' are available.  One way to implement
and use a fixture in ERT is

@lisp
(defun my-fixture (body)
  (unwind-protect
      (progn [set up]
             (funcall body))
    [tear down]))

(ert-deftest my-test ()
             (my-fixture
              (lambda ()
                [test code])))
@end lisp

(Another way would be a @code{with-my-fixture} macro.)  This solves
the set-up and tear-down part, and additionally allows any test case
to use any combination of fixtures, so it is more general than what
other tools typically allow.

If the test case needs access to the environment the fixture sets
up, the fixture can be modified to pass arguments to the body.

These are standard Lisp idioms.  Special syntax for them could be
added easily enough, but would provide only a minor simplification.

(Note that splitting set-up and tear-down into separate functions,
like *Unit tools usually do, makes it impossible to establish
dynamic `let' bindings as part of the fixture.  So, blindly
imitating the way fixtures are implemented in other languages would
be counter-productive in Lisp.)

The purpose of test suites is to group related test cases together.
The most common use of this is to run just the tests for one
particular module.  Since symbol prefixes are the usual way of
separating module namespaces in Emacs Lisp, test selectors already
solve this by allowing regexp matching on test names; e.g., the
selector "^ert-" selects ERT's self-tests.

If test suites containing arbitrary sets of tests are found to be
desirable, it would be easy to add a `define-test-selector' mechanism
that introduces a new selector, defined in terms of existing ones;
e.g.

@lisp
;; Note that `define-test-selector' does not exist yet.
(define-test-selector my-test-suite () `(member foo-test bar-test))
@end lisp

would define a test suite named @code{my-test-suite} consisting of
@code{foo-test} and @code{bar-test}.  See also @code{deftype} in
Common Lisp.

@c @kbd{M-x ert}

@bye
